<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>H3AthenaUDFHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">aws-athena-udfs-h3</a> &gt; <a href="index.source.html" class="el_package">io.jyde.aws.athena.connectors.udf.h3</a> &gt; <span class="el_source">H3AthenaUDFHandler.java</span></div><h1>H3AthenaUDFHandler.java</h1><pre class="source lang-java linenums">/* Licensed under Apache-2.0 2021. */
package io.jyde.aws.athena.connectors.udf.h3;

import com.amazonaws.athena.connector.lambda.handlers.UserDefinedFunctionHandler;
import com.google.common.annotations.VisibleForTesting;
import com.uber.h3core.AreaUnit;
import com.uber.h3core.H3Core;
import com.uber.h3core.LengthUnit;
import com.uber.h3core.exceptions.DistanceUndefinedException;
import com.uber.h3core.exceptions.LineUndefinedException;
import com.uber.h3core.exceptions.PentagonEncounteredException;
import com.uber.h3core.util.GeoCoord;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class H3AthenaUDFHandler extends UserDefinedFunctionHandler {
    private static final String SOURCE_TYPE = &quot;io.jyde.aws&quot;;

    private final H3Core h3Core;

    public H3AthenaUDFHandler() throws IOException {
<span class="fc" id="L26">        super(SOURCE_TYPE);</span>
<span class="fc" id="L27">        this.h3Core = H3Core.newInstance();</span>
<span class="fc" id="L28">    }</span>

    @VisibleForTesting
    H3AthenaUDFHandler(H3Core h3Core) {
<span class="nc" id="L32">        super(SOURCE_TYPE);</span>
<span class="nc" id="L33">        this.h3Core = h3Core;</span>
<span class="nc" id="L34">    }</span>

    /** Returns true if this is a valid H3 index. */
    public Boolean h3_is_valid(Long h3) {
<span class="pc bpc" id="L38" title="1 of 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L39">            return null;</span>
        }
<span class="fc" id="L41">        return h3Core.h3IsValid(h3);</span>
    }

    /** Returns true if this is a valid H3 index. */
    public Boolean h3_is_valid(String h3_address) {
<span class="pc bpc" id="L46" title="1 of 2 branches missed.">        if (h3_address == null) {</span>
<span class="nc" id="L47">            return null;</span>
        }
<span class="fc" id="L49">        return h3Core.h3IsValid(h3_address);</span>
    }

    /** Returns the base cell number for this index. */
    public Integer h3_get_base_cell(Long h3) {
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L55">            return null;</span>
        }
<span class="fc" id="L57">        return h3Core.h3GetBaseCell(h3);</span>
    }

    /** Returns the base cell number for this index. */
    public Integer h3_get_base_cell(String h3_address) {
<span class="fc" id="L62">        return h3Core.h3GetBaseCell(h3_address);</span>
    }

    /** Returns &lt;code&gt;true&lt;/code&gt; if this index is one of twelve pentagons per resolution. */
    public Boolean h3_is_pentagon(Long h3) {
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L68">            return null;</span>
        }
<span class="fc" id="L70">        return h3Core.h3IsPentagon(h3);</span>
    }

    /** Returns &lt;code&gt;true&lt;/code&gt; if this index is one of twelve pentagons per resolution. */
    public Boolean h3_is_pentagon(String h3_address) {
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">        if (h3_address == null) {</span>
<span class="nc" id="L76">            return null;</span>
        }
<span class="fc" id="L78">        return h3Core.h3IsPentagon(h3_address);</span>
    }

    /**
     * Find the H3 index of the resolution &lt;code&gt;res&lt;/code&gt; cell containing the lat/lon (in degrees)
     *
     * @param lat Latitude in degrees.
     * @param lng Longitude in degrees.
     * @param res Resolution, 0 &amp;lt;= res &amp;lt;= 15
     * @return The H3 index.
     * @throws IllegalArgumentException latitude, longitude, or resolution are out of range.
     */
    public Long geo_to_h3(Double lat, Double lng, Integer res) throws IllegalArgumentException {
<span class="pc bpc" id="L91" title="2 of 4 branches missed.">        if (lat == null || lng == null) {</span>
<span class="nc" id="L92">            return null;</span>
        }
<span class="fc" id="L94">        return h3Core.geoToH3(lat, lng, res);</span>
    }

    /**
     * Find the H3 index of the resolution &lt;code&gt;res&lt;/code&gt; cell containing the lat/lon (in degrees)
     *
     * @param lat Latitude in degrees.
     * @param lng Longitude in degrees.
     * @param res Resolution, 0 &amp;lt;= res &amp;lt;= 15
     * @return The H3 index.
     * @throws IllegalArgumentException Latitude, longitude, or resolution is out of range.
     */
    public String geo_to_h3_address(Double lat, Double lng, Integer res)
            throws IllegalArgumentException {
<span class="pc bpc" id="L108" title="2 of 4 branches missed.">        if (lat == null || lng == null) {</span>
<span class="nc" id="L109">            return null;</span>
        }
<span class="fc" id="L111">        return h3Core.geoToH3Address(lat, lng, res);</span>
    }

    /** Find the latitude, longitude (both in degrees) center point of the cell. */
    public String h3_to_geo(Long h3) {
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L117">            return null;</span>
        }
<span class="nc" id="L119">        return geoCoordToWKTPoint(h3Core.h3ToGeo(h3));</span>
    }

    /** Find the latitude, longitude (degrees) center point of the cell. */
    public String h3_to_geo(String h3_address) throws IllegalArgumentException {
<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (h3_address == null) {</span>
<span class="nc" id="L125">            return null;</span>
        }
<span class="nc" id="L127">        return geoCoordToWKTPoint(h3Core.h3ToGeo(h3_address));</span>
    }

    /**
     * Find the cell boundary in latitude, longitude (degrees) coordinates for the cell
     *
     * @param h3 H3 index.
     * @return A list of WKT Point strings.
     * @throws IllegalArgumentException
     */
    public List&lt;String&gt; h3_to_geo_boundary(Long h3) throws IllegalArgumentException {
<span class="nc bnc" id="L138" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L139">            return null;</span>
        }
<span class="nc" id="L141">        return h3Core.h3ToGeoBoundary(h3).stream()</span>
<span class="nc" id="L142">                .map(this::geoCoordToWKTPoint)</span>
<span class="nc" id="L143">                .collect(Collectors.toList());</span>
    }

    /**
     * Find the cell boundary in latitude, longitude (degrees) coordinates for the cell
     *
     * @param h3_address H3 index address.
     * @return A list of WKT Point strings.
     * @throws IllegalArgumentException
     */
    public List&lt;String&gt; h3_to_geo_boundary(String h3_address) throws IllegalArgumentException {
<span class="nc bnc" id="L154" title="All 2 branches missed.">        if (h3_address == null) {</span>
<span class="nc" id="L155">            return null;</span>
        }
<span class="nc" id="L157">        return h3Core.h3ToGeoBoundary(h3_address).stream()</span>
<span class="nc" id="L158">                .map(this::geoCoordToWKTPoint)</span>
<span class="nc" id="L159">                .collect(Collectors.toList());</span>
    }

    /**
     * Neighboring indexes in all directions.
     *
     * @param h3 Origin index.
     * @param k Number of rings around the origin.
     * @return A list of H3 indexes forming a ring k cells away from the origin.
     * @throws IllegalArgumentException
     */
    public List&lt;Long&gt; k_ring(Long h3, Integer k) throws IllegalArgumentException {
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L172">            return null;</span>
        }
<span class="fc" id="L174">        return h3Core.kRing(h3, k);</span>
    }

    /**
     * Neighboring addresses in all directions.
     *
     * @param h3_address Origin index address.
     * @param k Number of rings around the origin.
     * @return A list of H3 index addresses forming a ring k cells away from the origin.
     * @throws IllegalArgumentException
     */
    public List&lt;String&gt; k_ring(String h3_address, Integer k) throws IllegalArgumentException {
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (h3_address == null) {</span>
<span class="nc" id="L187">            return null;</span>
        }
<span class="fc" id="L189">        return h3Core.kRing(h3_address, k);</span>
    }

    /**
     * Returns in order neighbor traversal, of indexes with distance of &lt;code&gt;k&lt;/code&gt;.
     *
     * @param h3 Origin index.
     * @param k Number of rings around the origin.
     * @return All indexes &lt;code&gt;k&lt;/code&gt; away from the origin.
     * @throws PentagonEncounteredException A pentagon or pentagonal distortion was encountered.
     */
    public List&lt;Long&gt; hex_ring(Long h3, Integer k) throws PentagonEncounteredException {
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L202">            return null;</span>
        }
<span class="nc" id="L204">        return h3Core.hexRing(h3, k);</span>
    }

    /**
     * Returns in order neighbor traversal, of indexes with distance of &lt;code&gt;k&lt;/code&gt;.
     *
     * @param h3_address Origin index address.
     * @param k Number of rings around the origin.
     * @return All indexes &lt;code&gt;k&lt;/code&gt; away from the origin.
     * @throws PentagonEncounteredException A pentagon or pentagonal distortion was encountered.
     */
    public List&lt;String&gt; hex_ring(String h3_address, Integer k) throws PentagonEncounteredException {
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (h3_address == null) {</span>
<span class="nc" id="L217">            return null;</span>
        }
<span class="nc" id="L219">        return h3Core.hexRing(h3_address, k);</span>
    }

    /**
     * Returns the distance between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. This is the grid distance, or
     * distance expressed in number of H3 cells.
     *
     * &lt;p&gt;In some cases H3 cannot compute the distance between two indexes. This can happen because:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;The indexes are not comparable (difference resolutions, etc)
     *   &lt;li&gt;The distance is greater than the H3 core library supports
     *   &lt;li&gt;The H3 library does not support finding the distance between the two cells, because of
     *       pentagonal distortion.
     * &lt;/ul&gt;
     *
     * @param a An H3 index.
     * @param b Another H3 index.
     * @return Distance between the two in grid cells.
     * @throws RuntimeException H3 cannot compute the distance because the two cells have different
     *     resolutions.
     */
    public Integer h3_distance(Long a, Long b) {
<span class="pc bpc" id="L242" title="1 of 4 branches missed.">        if (a == null || b == null) {</span>
<span class="fc" id="L243">            return null;</span>
        }
        try {
<span class="fc" id="L246">            return h3Core.h3Distance(a, b);</span>
<span class="fc" id="L247">        } catch (DistanceUndefinedException e) {</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">            if (h3Core.h3GetResolution(a) != h3Core.h3GetResolution(b)) {</span>
<span class="fc" id="L249">                throw new RuntimeException(</span>
                        &quot;The H3 library does not support finding the distance between the two cells with different resolutions.&quot;,
                        e);
            }
<span class="fc" id="L253">            return null;</span>
        }
    }

    /**
     * Returns the distance between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. This is the grid distance, or
     * distance expressed in number of H3 cells.
     *
     * &lt;p&gt;In some cases H3 cannot compute the distance between two indexes. This can happen because:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;The indexes are not comparable (difference resolutions, etc)
     *   &lt;li&gt;The distance is greater than the H3 core library supports
     *   &lt;li&gt;The H3 library does not support finding the distance between the two cells, because of
     *       pentagonal distortion.
     * &lt;/ul&gt;
     *
     * @param a An H3 index address.
     * @param b Another H3 index address.
     * @return Distance between the two in grid cells.
     * @throws RuntimeException H3 cannot compute the distance because the two cells have different
     *     resolutions.
     */
    public Integer h3_distance(String a, String b) {
<span class="pc bpc" id="L277" title="1 of 4 branches missed.">        if (a == null || b == null) {</span>
<span class="fc" id="L278">            return null;</span>
        }
        try {
<span class="fc" id="L281">            return h3Core.h3Distance(a, b);</span>
<span class="fc" id="L282">        } catch (DistanceUndefinedException e) {</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">            if (h3Core.h3GetResolution(a) != h3Core.h3GetResolution(b)) {</span>
<span class="fc" id="L284">                throw new RuntimeException(</span>
                        &quot;The H3 library does not support finding the distance between the two cells with different resolutions.&quot;,
                        e);
            }
<span class="fc" id="L288">            return null;</span>
        }
    }

    /**
     * Given two H3 indexes, return the line of indexes between them (inclusive of endpoints).
     *
     * &lt;p&gt;This function may fail to find the line between two indexes, for example if they are very
     * far apart. It may also fail when finding distances for indexes on opposite sides of a
     * pentagon.
     *
     * &lt;p&gt;Notes:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;The specific output of this function should not be considered stable across library
     *       versions. The only guarantees the library provides are that the line length will be
     *       `h3Distance(start, end) + 1` and that every index in the line will be a neighbor of the
     *       preceding index.
     *   &lt;li&gt;Lines are drawn in grid space, and may not correspond exactly to either Cartesian lines
     *       or great arcs.
     * &lt;/ul&gt;
     *
     * @param start Start index of the line.
     * @param end End index of the line.
     * @return Indexes making up the line.
     * @throws LineUndefinedException The line could not be computed.
     */
    public List&lt;Long&gt; h3_line(Long start, Long end) {
<span class="pc bpc" id="L316" title="2 of 4 branches missed.">        if (start == null || end == null) {</span>
<span class="nc" id="L317">            return null;</span>
        }
        try {
<span class="fc" id="L320">            return h3Core.h3Line(start, end);</span>
<span class="nc" id="L321">        } catch (LineUndefinedException e) {</span>
<span class="nc" id="L322">            return null;</span>
        }
    }

    /**
     * Given two H3 indexes, return the line of indexes between them (inclusive of endpoints).
     *
     * &lt;p&gt;This function may fail to find the line between two indexes, for example if they are very
     * far apart. It may also fail when finding distances for indexes on opposite sides of a
     * pentagon.
     *
     * &lt;p&gt;Notes:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;The specific output of this function should not be considered stable across library
     *       versions. The only guarantees the library provides are that the line length will be
     *       `h3Distance(start, end) + 1` and that every index in the line will be a neighbor of the
     *       preceding index.
     *   &lt;li&gt;Lines are drawn in grid space, and may not correspond exactly to either Cartesian lines
     *       or great arcs.
     * &lt;/ul&gt;
     *
     * @param start_address Start index of the line.
     * @param end_address End index of the line.
     * @return Index addresses making up the line.
     * @throws LineUndefinedException The line could not be computed.
     */
    public List&lt;String&gt; h3_line(String start_address, String end_address) {
<span class="pc bpc" id="L350" title="2 of 4 branches missed.">        if (start_address == null || end_address == null) {</span>
<span class="nc" id="L351">            return null;</span>
        }
        try {
<span class="fc" id="L354">            return h3Core.h3Line(start_address, end_address);</span>
<span class="nc" id="L355">        } catch (LineUndefinedException e) {</span>
<span class="nc" id="L356">            return null;</span>
        }
    }

    /**
     * Finds indexes within the given geofence.
     *
     * @param points Outline geofence as a list of WKT Points.
     * @param holes Geofences of any internal holes as a list of lists containing WKT Points.
     * @param res Resolution of the desired indexes.
     * @return Indexes making up the area enclosed by points minus the area enclosed by holes.
     * @throws IllegalArgumentException Invalid resolution.
     */
    public List&lt;Long&gt; polyfill(List&lt;String&gt; points, List&lt;List&lt;String&gt;&gt; holes, Integer res)
            throws IllegalArgumentException {
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (points == null) {</span>
<span class="nc" id="L372">            return null;</span>
        }
<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (holes == null) {</span>
<span class="nc" id="L375">            holes = new ArrayList&lt;List&lt;String&gt;&gt;();</span>
        }
<span class="nc" id="L377">        List&lt;GeoCoord&gt; geoCoordPoints =</span>
<span class="nc" id="L378">                points.stream().map(this::geoCoordFromWKTPoint).collect(Collectors.toList());</span>
<span class="nc" id="L379">        List&lt;List&lt;GeoCoord&gt;&gt; geoCoordHoles =</span>
<span class="nc" id="L380">                holes.stream()</span>
<span class="nc" id="L381">                        .map(</span>
                                x -&gt;
<span class="nc" id="L383">                                        x.stream()</span>
<span class="nc" id="L384">                                                .map(this::geoCoordFromWKTPoint)</span>
<span class="nc" id="L385">                                                .collect(Collectors.toList()))</span>
<span class="nc" id="L386">                        .collect(Collectors.toList());</span>
<span class="nc" id="L387">        return h3Core.polyfill(geoCoordPoints, geoCoordHoles, res);</span>
    }

    /**
     * Finds indexes within the given geofence.
     *
     * @param points Outline geofence as a list of WKT Points.
     * @param holes Geofences of any internal holes as a list of lists containing WKT Points.
     * @param res Resolution of the desired indexes.
     * @return Index addresses making up the area enclosed by points minus the area enclosed by
     *     holes.
     * @throws IllegalArgumentException Invalid resolution.
     */
    public List&lt;String&gt; polyfill_address(List&lt;String&gt; points, List&lt;List&lt;String&gt;&gt; holes, Integer res)
            throws IllegalArgumentException {
<span class="nc bnc" id="L402" title="All 2 branches missed.">        if (points == null) {</span>
<span class="nc" id="L403">            return null;</span>
        }
<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (holes == null) {</span>
<span class="nc" id="L406">            holes = new ArrayList&lt;List&lt;String&gt;&gt;();</span>
        }
<span class="nc" id="L408">        List&lt;GeoCoord&gt; geoCoordPoints =</span>
<span class="nc" id="L409">                points.stream().map(this::geoCoordFromWKTPoint).collect(Collectors.toList());</span>
<span class="nc" id="L410">        List&lt;List&lt;GeoCoord&gt;&gt; geoCoordHoles =</span>
<span class="nc" id="L411">                holes.stream()</span>
<span class="nc" id="L412">                        .map(</span>
                                x -&gt;
<span class="nc" id="L414">                                        x.stream()</span>
<span class="nc" id="L415">                                                .map(this::geoCoordFromWKTPoint)</span>
<span class="nc" id="L416">                                                .collect(Collectors.toList()))</span>
<span class="nc" id="L417">                        .collect(Collectors.toList());</span>
<span class="nc" id="L418">        return h3Core.polyfillAddress(geoCoordPoints, geoCoordHoles, res);</span>
    }

    /**
     * Returns the resolution of the provided index
     *
     * @param h3 H3 index.
     */
    public Integer h3_get_resolution(Long h3) {
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L428">            return null;</span>
        }
<span class="fc" id="L430">        return h3Core.h3GetResolution(h3);</span>
    }

    /**
     * Returns the resolution of the provided index
     *
     * @param h3_address H3 index address.
     */
    public Integer h3_get_resolution(String h3_address) {
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">        if (h3_address == null) {</span>
<span class="nc" id="L440">            return null;</span>
        }
<span class="fc" id="L442">        return h3Core.h3GetResolution(h3_address);</span>
    }

    /**
     * Returns the parent of the index at the given resolution.
     *
     * @param h3 H3 index.
     * @param res Resolution of the parent, &lt;code&gt;0 &amp;lt;= res &amp;lt;= h3GetResolution(h3)&lt;/code&gt;
     * @throws IllegalArgumentException Invalid resolution
     */
    public Long h3_to_parent(Long h3, Integer res) throws IllegalArgumentException {
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L454">            return null;</span>
        }
<span class="fc" id="L456">        return h3Core.h3ToParent(h3, res);</span>
    }

    /**
     * Returns the parent of the index at the given resolution.
     *
     * @param h3_address H3 index.
     * @param res Resolution of the parent, &lt;code&gt;0 &amp;lt;= res &amp;lt;= h3GetResolution(h3)&lt;/code&gt;
     * @throws IllegalArgumentException Invalid resolution
     */
    public String h3_to_parent_address(String h3_address, Integer res)
            throws IllegalArgumentException {
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">        if (h3_address == null) {</span>
<span class="nc" id="L469">            return null;</span>
        }
<span class="fc" id="L471">        return h3Core.h3ToParentAddress(h3_address, res);</span>
    }

    /**
     * Provides the children of the index at the given resolution.
     *
     * @param h3 H3 index.
     * @param child_res Resolution of the children
     * @throws IllegalArgumentException Invalid resolution
     */
    public List&lt;Long&gt; h3_to_children(Long h3, Integer child_res) throws IllegalArgumentException {
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L483">            return null;</span>
        }
<span class="fc" id="L485">        return h3Core.h3ToChildren(h3, child_res);</span>
    }

    /**
     * Provides the children of the index at the given resolution.
     *
     * @param h3_address H3 index address.
     * @param child_res Resolution of the children
     * @throws IllegalArgumentException Invalid resolution
     */
    public List&lt;String&gt; h3_to_children(String h3_address, Integer child_res)
            throws IllegalArgumentException {
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">        if (h3_address == null) {</span>
<span class="nc" id="L498">            return null;</span>
        }
<span class="fc" id="L500">        return h3Core.h3ToChildren(h3_address, child_res);</span>
    }

    /**
     * Returns the center child at the given resolution.
     *
     * @param h3 Parent H3 index
     * @param child_res Resolution of the child
     * @throws IllegalArgumentException Invalid resolution (e.g. coarser than the parent)
     */
    public Long h3_to_center_child(Long h3, Integer child_res) throws IllegalArgumentException {
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L512">            return null;</span>
        }
<span class="fc" id="L514">        return h3Core.h3ToCenterChild(h3, child_res);</span>
    }

    /**
     * Returns the center child at the given resolution.
     *
     * @param h3_address Parent H3 index address
     * @param child_res Resolution of the child
     * @throws IllegalArgumentException Invalid resolution (e.g. coarser than the parent)
     */
    public String h3_to_center_child(String h3_address, Integer child_res)
            throws IllegalArgumentException {
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">        if (h3_address == null) {</span>
<span class="nc" id="L527">            return null;</span>
        }
<span class="fc" id="L529">        return h3Core.h3ToCenterChild(h3_address, child_res);</span>
    }

    /**
     * Determines if an index is Class III or Class II.
     *
     * @param h3 H3 index
     * @return &lt;code&gt;true&lt;/code&gt; if the index is Class III
     */
    public Boolean h3_is_res_class_iii(Long h3) {
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L540">            return null;</span>
        }
<span class="fc" id="L542">        return h3Core.h3IsResClassIII(h3);</span>
    }

    /**
     * Determines if an index is Class III or Class II.
     *
     * @param h3_address H3 index address.
     * @return &lt;code&gt;true&lt;/code&gt; if the index is Class III.
     */
    public Boolean h3_is_res_class_iii(String h3_address) {
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">        if (h3_address == null) {</span>
<span class="nc" id="L553">            return null;</span>
        }
<span class="fc" id="L555">        return h3Core.h3IsResClassIII(h3_address);</span>
    }

    /**
     * Returns a compacted set of indexes, at possibly coarser resolutions.
     *
     * @throws IllegalArgumentException Invalid input, such as duplicated indexes.
     */
    public List&lt;Long&gt; compact(List&lt;Long&gt; h3) {
<span class="nc bnc" id="L564" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L565">            return null;</span>
        }
<span class="nc" id="L567">        return h3Core.compact(h3);</span>
    }

    /** Returns a compacted set of indexes, at possibly coarser resolutions. */
    public List&lt;String&gt; compact_address(List&lt;String&gt; h3_addresses) {
<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (h3_addresses == null) {</span>
<span class="nc" id="L573">            return null;</span>
        }
<span class="nc" id="L575">        return h3Core.compactAddress(h3_addresses);</span>
    }

    /**
     * Uncompacts all the given indexes to resolution &lt;code&gt;res&lt;/code&gt;.
     *
     * @throws IllegalArgumentException Invalid input, such as indexes finer than &lt;code&gt;res&lt;/code&gt;.
     */
    public List&lt;Long&gt; uncompact(List&lt;Long&gt; h3, Integer res) {
<span class="nc bnc" id="L584" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L585">            return null;</span>
        }
<span class="nc" id="L587">        return h3Core.uncompact(h3, res);</span>
    }

    /** Uncompacts all the given indexes to resolution &lt;code&gt;res&lt;/code&gt;. */
    public List&lt;String&gt; uncompact_address(List&lt;String&gt; h3_addresses, Integer res) {
<span class="nc bnc" id="L592" title="All 2 branches missed.">        if (h3_addresses == null) {</span>
<span class="nc" id="L593">            return null;</span>
        }
<span class="nc" id="L595">        return h3Core.uncompactAddress(h3_addresses, res);</span>
    }

    /**
     * Converts from &lt;code&gt;long&lt;/code&gt; representation of an index to &lt;code&gt;String&lt;/code&gt;
     * representation.
     *
     * @param h3 H3 index.
     * @return H3 index address.
     */
    public String h3_to_string(Long h3) {
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L607">            return null;</span>
        }
<span class="fc" id="L609">        return h3Core.h3ToString(h3);</span>
    }

    /**
     * Converts from &lt;code&gt;String&lt;/code&gt; representation of an index to &lt;code&gt;long&lt;/code&gt;
     * representation.
     *
     * @param h3_address H3 index address.
     * @return H3 index.
     */
    public Long string_to_h3(String h3_address) {
<span class="pc bpc" id="L620" title="1 of 2 branches missed.">        if (h3_address == null) {</span>
<span class="nc" id="L621">            return null;</span>
        }
<span class="fc" id="L623">        return h3Core.stringToH3(h3_address);</span>
    }

    /**
     * Calculates the area of the given H3 cell.
     *
     * @param h3 Cell to find the area of.
     * @param unit Unit to calculate the area in.
     * @return Cell area in the given units.
     */
    public Double cell_area(Long h3, String unit) {
<span class="pc bpc" id="L634" title="1 of 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L635">            return null;</span>
        }
<span class="fc" id="L637">        return h3Core.cellArea(h3, AreaUnit.valueOf(unit));</span>
    }

    /**
     * Calculates the area of the given H3 cell.
     *
     * @param h3_address Cell to find the area of.
     * @param unit Unit to calculate the area in. One of: 'rads2', 'km2', 'm2'.
     * @return Cell area in the given units.
     */
    public Double cell_area(String h3_address, String unit) {
<span class="pc bpc" id="L648" title="1 of 2 branches missed.">        if (h3_address == null) {</span>
<span class="nc" id="L649">            return null;</span>
        }
<span class="fc" id="L651">        return h3Core.cellArea(h3_address, AreaUnit.valueOf(unit));</span>
    }

    /**
     * Return the distance along the sphere between two points.
     *
     * @param a First point as a WKT Point string.
     * @param b Second point as a WKT Point string.
     * @param unit Unit to return the distance in.
     * @return Distance from point &lt;code&gt;a&lt;/code&gt; to point &lt;code&gt;b&lt;/code&gt;
     */
    public Double point_dist(String a, String b, String unit) {
<span class="nc bnc" id="L663" title="All 4 branches missed.">        if (a == null || b == null) {</span>
<span class="nc" id="L664">            return null;</span>
        }
<span class="nc" id="L666">        GeoCoord aGeoCoord = geoCoordFromWKTPoint(a);</span>
<span class="nc" id="L667">        GeoCoord bGeoCoord = geoCoordFromWKTPoint(b);</span>
<span class="nc" id="L668">        return h3Core.pointDist(aGeoCoord, bGeoCoord, LengthUnit.valueOf(unit));</span>
    }

    /**
     * Calculate the edge length of the given H3 edge.
     *
     * @param edge Edge to find the edge length of.
     * @param unit Unit of measure to use.
     * @return Length of the given edge.
     */
    public Double exact_edge_length(Long edge, String unit) {
<span class="nc bnc" id="L679" title="All 2 branches missed.">        if (edge == null) {</span>
<span class="nc" id="L680">            return null;</span>
        }
<span class="nc" id="L682">        return h3Core.exactEdgeLength(edge, LengthUnit.valueOf(unit));</span>
    }

    /**
     * Calculate the edge length of the given H3 edge.
     *
     * @param edge_address Edge address to find the edge length of.
     * @param unit Unit of measure to use.
     * @return Length of the given edge.
     */
    public Double exact_edge_length(String edge_address, String unit) {
<span class="nc bnc" id="L693" title="All 2 branches missed.">        if (edge_address == null) {</span>
<span class="nc" id="L694">            return null;</span>
        }
<span class="nc" id="L696">        return h3Core.exactEdgeLength(edge_address, LengthUnit.valueOf(unit));</span>
    }

    /**
     * Returns the average area in &lt;code&gt;unit&lt;/code&gt; for indexes at resolution &lt;code&gt;res&lt;/code&gt;.
     *
     * @throws IllegalArgumentException Invalid parameter value
     */
    public Double hex_area(Integer res, String unit) {
<span class="nc" id="L705">        return h3Core.hexArea(res, AreaUnit.valueOf(unit));</span>
    }

    /**
     * Returns the average edge length in &lt;code&gt;unit&lt;/code&gt; for indexes at resolution &lt;code&gt;res
     * &lt;/code&gt;.
     *
     * @throws IllegalArgumentException Invalid parameter value
     */
    public Double edge_length(Integer res, String unit) {
<span class="nc" id="L715">        return h3Core.edgeLength(res, LengthUnit.valueOf(unit));</span>
    }

    /**
     * Returns the number of unique H3 indexes at resolution &lt;code&gt;res&lt;/code&gt;.
     *
     * @throws IllegalArgumentException Invalid resolution
     */
    public Long num_hexagons(Integer res) {
<span class="nc" id="L724">        return h3Core.numHexagons(res);</span>
    }

    /** Returns a collection of all base cells (H3 indexes are resolution 0). */
    public List&lt;Long&gt; get_res_0_indexes() {
<span class="nc" id="L729">        return new ArrayList&lt;Long&gt;(h3Core.getRes0Indexes());</span>
    }

    /** Returns a collection of all base cells (H3 indexes are resolution 0). */
    public List&lt;String&gt; get_res_0_indexes_addresses() {
<span class="nc" id="L734">        return new ArrayList&lt;String&gt;(h3Core.getRes0IndexesAddresses());</span>
    }

    /** Returns a collection of all base cells (H3 indexes are resolution 0). */
    public List&lt;Long&gt; get_pentagon_indexes(Integer res) {
<span class="nc" id="L739">        return new ArrayList&lt;Long&gt;(h3Core.getPentagonIndexes(res));</span>
    }

    /** Returns a collection of all base cells (H3 indexes are resolution 0). */
    public List&lt;String&gt; get_pentagon_indexes_addresses(Integer res) {
<span class="nc" id="L744">        return new ArrayList&lt;String&gt;(h3Core.getPentagonIndexesAddresses(res));</span>
    }

    /** Returns &lt;code&gt;true&lt;/code&gt; if the two indexes are neighbors. */
    public Boolean h3_indexes_are_neighbors(Long a, Long b) {
<span class="nc bnc" id="L749" title="All 4 branches missed.">        if (a == null || b == null) {</span>
<span class="nc" id="L750">            return null;</span>
        }
<span class="nc" id="L752">        return h3Core.h3IndexesAreNeighbors(a, b);</span>
    }

    /** Returns &lt;code&gt;true&lt;/code&gt; if the two indexes are neighbors. */
    public Boolean h3_indexes_are_neighbors(String a, String b) {
<span class="nc bnc" id="L757" title="All 4 branches missed.">        if (a == null || b == null) {</span>
<span class="nc" id="L758">            return null;</span>
        }
<span class="nc" id="L760">        return h3Core.h3IndexesAreNeighbors(a, b);</span>
    }

    /** Returns a unidirectional edge index representing &lt;code&gt;a&lt;/code&gt; towards &lt;code&gt;b&lt;/code&gt;. */
    public Long get_h3_unidirectional_edge(Long a, Long b) {
<span class="nc bnc" id="L765" title="All 4 branches missed.">        if (a == null || b == null) {</span>
<span class="nc" id="L766">            return null;</span>
        }
        try {
<span class="nc" id="L769">            return h3Core.getH3UnidirectionalEdge(a, b);</span>
<span class="nc" id="L770">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L771">            return null;</span>
        }
    }

    /** Returns a unidirectional edge index representing &lt;code&gt;a&lt;/code&gt; towards &lt;code&gt;b&lt;/code&gt;. */
    public String get_h3_unidirectional_edge(String a, String b) {
<span class="nc bnc" id="L777" title="All 4 branches missed.">        if (a == null || b == null) {</span>
<span class="nc" id="L778">            return null;</span>
        }
        try {
<span class="nc" id="L781">            return h3Core.getH3UnidirectionalEdge(a, b);</span>
<span class="nc" id="L782">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L783">            return null;</span>
        }
    }

    /** Returns &lt;code&gt;true&lt;/code&gt; if the given index is a valid unidirectional edge. */
    public Boolean h3_unidirectional_edge_is_valid(Long h3) {
<span class="nc bnc" id="L789" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L790">            return null;</span>
        }
<span class="nc" id="L792">        return h3Core.h3UnidirectionalEdgeIsValid(h3);</span>
    }

    /** Returns &lt;code&gt;true&lt;/code&gt; if the given index is a valid unidirectional edge. */
    public Boolean h3_unidirectional_edge_is_valid(String h3) {
<span class="nc bnc" id="L797" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L798">            return null;</span>
        }
<span class="nc" id="L800">        return h3Core.h3UnidirectionalEdgeIsValid(h3);</span>
    }

    /** Returns the origin index of the given unidirectional edge. */
    public Long get_origin_h3_index_from_unidirectional_edge(Long h3) {
<span class="nc bnc" id="L805" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L806">            return null;</span>
        }
<span class="nc" id="L808">        return h3Core.getOriginH3IndexFromUnidirectionalEdge(h3);</span>
    }

    /** Returns the origin index of the given unidirectional edge. */
    public String get_origin_h3_index_from_unidirectional_edge(String h3) {
<span class="nc bnc" id="L813" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L814">            return null;</span>
        }
<span class="nc" id="L816">        return h3Core.getOriginH3IndexFromUnidirectionalEdge(h3);</span>
    }

    /** Returns the destination index of the given unidirectional edge. */
    public Long get_destination_h3_index_from_unidirectional_edge(Long h3) {
<span class="nc bnc" id="L821" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L822">            return null;</span>
        }
<span class="nc" id="L824">        return h3Core.getDestinationH3IndexFromUnidirectionalEdge(h3);</span>
    }

    /** Returns the destination index of the given unidirectional edge. */
    public String get_destination_h3_index_from_unidirectional_edge(String h3) {
<span class="nc bnc" id="L829" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L830">            return null;</span>
        }
<span class="nc" id="L832">        return h3Core.getDestinationH3IndexFromUnidirectionalEdge(h3);</span>
    }

    /**
     * Returns the origin and destination indexes (in that order) of the given unidirectional edge.
     */
    public List&lt;Long&gt; get_h3_indexes_from_unidirectional_edge(Long h3) {
<span class="nc bnc" id="L839" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L840">            return null;</span>
        }
<span class="nc" id="L842">        return h3Core.getH3IndexesFromUnidirectionalEdge(h3);</span>
    }

    /**
     * Returns the origin and destination indexes (in that order) of the given unidirectional edge.
     */
    public List&lt;String&gt; get_h3_indexes_from_unidirectional_edge(String h3) {
<span class="nc bnc" id="L849" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L850">            return null;</span>
        }
<span class="nc" id="L852">        return h3Core.getH3IndexesFromUnidirectionalEdge(h3);</span>
    }

    /** Returns all unidirectional edges originating from the given index. */
    public List&lt;Long&gt; get_h3_unidirectional_edges_from_hexagon(Long h3) {
<span class="nc bnc" id="L857" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L858">            return null;</span>
        }
<span class="nc" id="L860">        return h3Core.getH3UnidirectionalEdgesFromHexagon(h3);</span>
    }

    /** Returns all unidirectional edges originating from the given index. */
    public List&lt;String&gt; get_h3_unidirectional_edges_from_hexagon(String h3) {
<span class="nc bnc" id="L865" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L866">            return null;</span>
        }
<span class="nc" id="L868">        return h3Core.getH3UnidirectionalEdgesFromHexagon(h3);</span>
    }

    /** Returns a list of coordinates representing the given edge. */
    public List&lt;String&gt; get_h3_unidirectional_edge_boundary(Long h3) {
<span class="nc bnc" id="L873" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L874">            return null;</span>
        }
<span class="nc" id="L876">        return h3Core.getH3UnidirectionalEdgeBoundary(h3).stream()</span>
<span class="nc" id="L877">                .map(this::geoCoordToWKTPoint)</span>
<span class="nc" id="L878">                .collect(Collectors.toList());</span>
    }

    /** Returns a list of coordinates representing the given edge. */
    public List&lt;String&gt; get_h3_unidirectional_edge_boundary(String h3) {
<span class="nc bnc" id="L883" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L884">            return null;</span>
        }
<span class="nc" id="L886">        return h3Core.getH3UnidirectionalEdgeBoundary(h3).stream()</span>
<span class="nc" id="L887">                .map(this::geoCoordToWKTPoint)</span>
<span class="nc" id="L888">                .collect(Collectors.toList());</span>
    }

    /**
     * Find all icosahedron faces intersected by a given H3 index, represented as integers from
     * 0-19.
     *
     * @param h3 Index to find icosahedron faces for.
     * @return A collection of faces intersected by the index.
     */
    public List&lt;Integer&gt; h3_get_faces(Long h3) {
<span class="nc bnc" id="L899" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L900">            return null;</span>
        }
<span class="nc" id="L902">        return new ArrayList&lt;Integer&gt;(h3Core.h3GetFaces(h3));</span>
    }

    /**
     * Find all icosahedron faces intersected by a given H3 index, represented as integers from
     * 0-19.
     *
     * @param h3 Index to find icosahedron faces for.
     * @return A collection of faces intersected by the index.
     */
    public List&lt;Integer&gt; h3_get_faces(String h3) {
<span class="nc bnc" id="L913" title="All 2 branches missed.">        if (h3 == null) {</span>
<span class="nc" id="L914">            return null;</span>
        }
<span class="nc" id="L916">        return new ArrayList&lt;Integer&gt;(h3Core.h3GetFaces(h3));</span>
    }

    private String geoCoordToWKTPoint(GeoCoord geoCoord) {
<span class="nc" id="L920">        return String.format(&quot;POINT (%f %f)&quot;, geoCoord.lng, geoCoord.lat);</span>
    }

    /**
     * https://stackoverflow.com/a/5011958
     *
     * @param WKTPoint A String representation of a WKT Point in AWS Athena
     * @return An H3Core.util.GeoCoord object
     */
    private GeoCoord geoCoordFromWKTPoint(String WKTPoint) {
<span class="nc" id="L930">        Pattern p = Pattern.compile(&quot;\\d+(\\.\\d+)?&quot;);</span>
<span class="nc" id="L931">        Matcher m = p.matcher(WKTPoint);</span>
<span class="nc" id="L932">        m.find();</span>
<span class="nc" id="L933">        double lng = Double.parseDouble(m.group());</span>
<span class="nc" id="L934">        m.find();</span>
<span class="nc" id="L935">        double lat = Double.parseDouble(m.group());</span>
<span class="nc" id="L936">        return new GeoCoord(lat, lng);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>